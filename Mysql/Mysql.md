# Mysql

## Mysql日志
包含错误日志、慢查询日志、binlog、redolog、undolog等
MySQL 核心日志对比表

| **特性**          | **Binlog (二进制日志)**                          | **Redo Log (重做日志)**                      | **Undo Log (回滚日志)**                      |
|-------------------|------------------------------------------------|---------------------------------------------|---------------------------------------------|
| **用途**          | 主从复制、数据恢复（逻辑层）                     | 崩溃恢复（物理层），保证事务持久性            | 事务回滚、MVCC 多版本并发控制                 |
| **存储引擎**      | 所有引擎通用                                    | InnoDB 引擎特有                              | InnoDB 引擎特有                              |
| **日志类型**      | 逻辑日志（记录操作语句或行变更）                 | 物理日志（记录数据页的修改）                  | 逻辑日志（记录逆向操作）                     |
| **存储内容**      | 所有数据变更（DDL/DML）                        | 未提交事务的脏页修改                          | 事务修改前的旧版本数据                       |
| **刷盘时机**      | 事务提交后写入，由 `sync_binlog` 控制刷盘策略    | 事务进行中持续写入，提交时强制刷盘（`innodb_flush_log_at_trx_commit`） | 事务开始前记录修改，提交后进入待清理状态       |
| **生命周期**      | 长期保留（可配置过期时间）                      | 循环覆盖（固定大小文件组）                    | 事务提交后进入待清理队列，由 Purge 线程回收   |
| **是否可关闭**    | 可关闭（`log_bin=OFF`）                        | 不可关闭（核心崩溃恢复机制）                  | 不可关闭（事务回滚和 MVCC 依赖）              |
| **其他特点**      | 支持三种格式（STATEMENT/ROW/MIXED）             | 采用 WAL (Write-Ahead Logging) 机制           | 支持多版本快照读，隔离级别依赖                |

---

### **补充说明**
#### 1. **核心区别**
| **维度**       | **Binlog**                          | **Redo Log**                     | **Undo Log**                     |
|---------------|-------------------------------------|----------------------------------|----------------------------------|
| **层级**      | 服务层（跨引擎）                    | 引擎层（InnoDB 专属）            | 引擎层（InnoDB 专属）            |
| **数据恢复**  | 逻辑恢复（时间点恢复）              | 物理恢复（崩溃恢复）             | 事务回滚（逻辑回退）             |
| **写入方式**  | 追加写入                            | 循环写入                         | 链式存储（版本链）               |

### 2. **刷盘策略**
- **Binlog**  
  - `sync_binlog=0`：依赖系统刷盘  
  - `sync_binlog=1`：事务提交时同步刷盘（安全但性能低）  
  - `sync_binlog=N`：每 N 个事务批量刷盘（平衡性能与安全）  

- **Redo Log**  
  - `innodb_flush_log_at_trx_commit=1`：事务提交时同步刷盘（ACID 保障）  
  - `innodb_flush_log_at_trx_commit=0/2`：异步刷盘（性能优化，可能丢数据）  

### 3. **关联与协作**
- **二阶段提交（2PC）**：  
  Binlog 和 Redo Log 通过二阶段提交保证事务一致性：  
  1. Prepare 阶段：Redo Log 刷盘  
  2. Commit 阶段：Binlog 刷盘，Redo Log 标记提交  

- **数据恢复流程**：  
  崩溃恢复时，先通过 Redo Log 重放物理修改到数据页，再通过 Binlog 补充未同步的逻辑操作。

### 4. **性能优化**
- **Binlog**：ROW 格式更安全但日志量大，STATEMENT 格式日志小但主从不一致风险高。  
> - statement 记录执行过的 sql 语句，但是比如有一些内置函数如 now()，通过语句无法复现当时的数据，
> - row 记录语句与当时的值
- **Redo Log**：设置合理的日志文件大小（`innodb_log_file_size`）减少刷盘频率。  
- **Undo Log**：避免长事务导致 Undo 链过长，影响 Purge 效率。


## MySQL 事务

事务是数据库操作的逻辑单元，保证数据操作的 **ACID 特性**。以下是 MySQL 事务的核心知识点总结。

---

### 事务的 ACID 特性

| **特性**      | **描述**                                                                 | **实现机制**                              |
|---------------|--------------------------------------------------------------------------|------------------------------------------|
| **原子性**    | 事务内的操作要么全部成功，要么全部回滚                                   | Undo Log（记录逆向操作）                  |
| **一致性**    | 事务执行前后数据库状态保持一致（业务逻辑约束）                           | 由开发者 + 数据库约束（如主键、外键）保证 |
| **隔离性**    | 并发事务之间操作相互隔离，避免数据不一致                                 | 锁机制 + MVCC                            |
| **持久性**    | 事务提交后数据永久保存，即使系统崩溃也不丢失                             | Redo Log（重做日志）                      |

---

### 事务隔离级别

#### 1. 隔离级别对比
| **隔离级别**             | **脏读** | **不可重复读** | **幻读** | **实现方式**                     |
|--------------------------|----------|----------------|----------|----------------------------------|
| 读未提交 (READ UNCOMMITTED) | 可能     | 可能           | 可能     | 直接读取最新数据                 |
| 读已提交 (READ COMMITTED)   | 不可能   | 可能           | 可能     | 每次 SELECT 生成新 ReadView （每行语句生成一次ReadView）     |
| 可重复读 (REPEATABLE READ)  | 不可能   | 不可能         | 可能(*)  | 首次 SELECT 生成 ReadView + 间隙锁（一次事务生成一次ReadView） |
| 串行化 (SERIALIZABLE)       | 不可能   | 不可能         | 不可能   | 全表锁                           |

三种现象：
- 脏读：事务A读到别的事务未回滚的数据，事务B修改了一条数据x -> 事务A读到了x -> 事务B回滚
- 不可重复读：事务A先读到一条数据，然后去执行其他逻辑，再回来读取同一行数据时，数据被别的事务修改了，两次读取的数据不一致
- 幻读：事务A通过索引条件读取到了N条数据，然后去执行其他逻辑，事务B在此期间在N这个数据区间新增、删除了M条数据，导致事务A再回来读取时，发现 多/少 了M条数据

> **注**：  
> - MySQL（innodb） 默认隔离级别为 **REPEATABLE READ**  
> - (*) 在 RR 级别下通过 **间隙锁（Gap Lock）** 可避免大部分幻读（能解决当前读的幻读问题）

### 快照读仍存在幻读情况的demo
1. 当前DB已有id 5, 10, 15三条数据。
2. 事务A查询id < 10的数据，可以查出一行记录id = 5
3. 事务B插入id = 6的数据
4. 事务A再查询id < 10的数据，可以查出一行记录id = 5，查不出id = 6的数据（读场景，解决了幻读）
5. 事务A可以更新/删除id = 6的数据，不能插入id = 6的数据（写场景，幻读不彻底）
> 快照读不会加锁，当出现 事务A快照读 -> 事务B插入 -> 事务A当前读(select ... for update、 select ... lock in share mode、 update、 insert into、 delete from)，就会发生幻读问题
---

### 事务操作语法

#### 1. 显式事务控制
```sql
-- 开启事务
START TRANSACTION;  -- 或 BEGIN;

-- 执行操作
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;

-- 设置保存点
SAVEPOINT sp1;
-- 回滚到保存点
ROLLBACK TO sp1;
```
设置事务隔离级别
```sql
-- 全局设置
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 会话级设置
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 仅对下一个事务生效
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```



## MVCC 机制详解

MVCC（Multi-Version Concurrency Control，多版本并发控制）是 InnoDB 实现事务隔离级别的核心技术，通过数据多版本实现读写并行化，提高数据库并发性能。

---

### 一、MVCC 核心组件

#### 1. **版本链**
undolog每行记录包含两个隐藏字段：
- `DB_TRX_ID`：最近修改该行的事务 ID（6字节）
- `DB_ROLL_PTR`：指向 Undo Log 的回滚指针（7字节）

**版本链结构**：  
通过 `DB_ROLL_PTR` 将当前记录与历史版本连接成链表，用于实现快照读。

#### 2. **Undo Log**
- 存储数据修改前的旧版本（用于回滚和版本链构建）
- 类型：`INSERT_UNDO_LOG`（插入回滚）和 `UPDATE_UNDO_LOG`（更新回滚）

#### 3. **ReadView**
事务执行快照读时生成的视图，包含：
- `m_ids`：生成 ReadView 时活跃的事务 ID 列表
- `min_trx_id`：活跃事务中最小事务 ID
- `max_trx_id`：系统预分配的下一个事务 ID
- `creator_trx_id`：创建 ReadView 的事务 ID

> 只读事务不分配trx_id（会分配一个假trx_id），只有涉及到数据更新才会分配事务ID。


---

### 二、可见性判断规则

判断当前事务能否访问某行记录的某个版本：
1. 若记录的 `trx_id` == `creator_trx_id` → **可见**（当前事务修改）
2. 若记录的 `trx_id` < `min_trx_id` → **可见**（事务已提交）
3. 若记录的 `trx_id` > `max_trx_id` → **不可见**（事务在 ReadView 后启动）
4. 若 `trx_id` 在 `m_ids` 中 → **不可见**（事务未提交）
5. 否则 → **可见**（事务已提交）

---

### 三、不同隔离级别的实现差异

| **隔离级别**        | **ReadView 生成时机**              | **解决并发问题**           |
|---------------------|-----------------------------------|---------------------------|
| 读未提交（RU）      | 不使用 MVCC，直接读最新数据       | 无                        |
| 读已提交（RC）      | 每次 SELECT 生成新 ReadView       | 脏读                      |
| 可重复读（RR）      | 第一次 SELECT 生成 ReadView       | 脏读、不可重复读、部分幻读 |
| 串行化（Serializable）| 通过锁机制实现                   | 所有问题                   |

---