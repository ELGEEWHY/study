# Java核心知识
## 基本数据类型
### 八种基本数据类型
- 6 种数字类型：
    - 4 种整数型：byte、short、int、long
    - 2 种浮点型：float、double
- 1 种字符类型：char
- 1 种布尔型：boolean。

### 基本类型 与 包装类型区别
- 用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
- 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中，被 static 修饰 JDK 1.7 及之前位于方法区，1.8 后存放于元空间 。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- 默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。
- 比较方式：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。

### 包装类的缓存机制
Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 true / false,超过缓存范围创建新的对象。

浮点类型包装类 Float、Double 没有缓存机制

### 自动装箱、拆箱
Java 1.5 引入

    # 自动装箱
    Integer i = 40;
    # 相当于编译器自动做以下语法编译
    Integer i = Integer.valueOf(40);

    # 自动拆箱
    Integer i = 100;
    int k = i;
    # 相当于编译器自动做以下语法编译
    int k = i.intValue();


### 有了基本类型为什么还要有包装类（面试问到过）
让基本类型具有对象的特征，满足面向对象的设计思想，通过拆箱、装箱能在别的地方使用，如集合、泛型等，也可以在包装类中添加别的属性、方法，丰富基本类型的使用

> 引申问题：
> 为什么泛型不使用基本类型？
> 
> 泛型
> Java 泛型是在 JDK 5.0 引入的，目的是在编译阶段提供类型检查，增强代码的安全性和可读性。但 Java 为了保持与旧版本代码的兼容性，采用了 **类型擦除** 的方式来实现泛型。
> 
> 类型擦除(编译过程中的一种行为)
> - 类型替换：所有泛型类型的实例都会被替换为它们最接近的非泛型上限。如果没有指定上限，则默认为Object。例如，List<String>会被替换为List<Object>，而List<? extends Number>会被替换为List<Number>。
> - 桥接方法：为了保持多态性，当一个子类继承了父类并且重写了带有泛型的方法签名时，编译器会在子类中插入额外的方法，这些方法被称为桥接方法。这些方法的存在是为了确保父类和子类之间的方法调用能够正确地进行类型转换。
> - 强制类型转换：虽然实际的对象是以Object的形式存在，但编译器会在适当的地方插入强制类型转换的代码，以确保只有正确的类型可以被放入集合或从集合中取出。这样可以在编译阶段就检查出类型不匹配的问题。
> - 未受检警告：对于那些使用了原始类型（即没有泛型参数的旧式集合）的代码，编译器会产生未受检警告，但是仍然允许这样的代码存在，以便向后兼容旧版本的Java代码。


### 字符型常量、字符串常量
- 形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
- 含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
- 占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。
 
⚠️ char 类型是 16 位无符号整数（占用 2 字节），用于表示 UTF-16 编码的 Unicode 字符

- Unicode 字符集：为全球所有字符分配唯一编号（称为 代码点，如 U+4E2D 表示汉字“中”）。

- UTF-16 编码：将 Unicode 代码点转换为具体的二进制存储格式。

    - 基本多文种平面（BMP）：代码点范围 U+0000 到 U+FFFF，可直接用 1 个 char 存储（如大多数常用汉字，常用汉字编码 U+4E00 到 U+9FFF）。

    - 补充平面（如表情符号、部分生僻汉字）：代码点范围 U+10000 到 U+10FFFF，需要用 2 个 char 组成的代理对 表示。

            public static void main(String[] args) throws       Exception {
                char a = '刘';
                System.out.println(a);
                System.out.println((int) a);
                System.out.println((char) 21016);
                //char b = '\uD840\uDC00'   char 无法表示 𠀀 字
                //𠀀   U+20000
                String s = "\uD840\uDC00";
                System.out.println(s);
                //输出131072  U+20000的十进制形式
                System.out.println(s.codePointAt(0));
            }

![上方代码输出结果](/Java/基础/pic/char_demo.jpg)
            

## 面向对象
### 封装、继承、多态


## 集合
### 集合的比较
- 实体类实现Comparable<T>接口，并实现 compareTo(T t) 方法，我们称为内部比较器

- 创建一个外部比较器，这个外部比较器要实现Comparator接口的 compare(T t1, T t2)方法

| **特性**               | **`Comparable`**                              | **`Comparator`**                              |
|------------------------|-----------------------------------------------|-----------------------------------------------|
| **接口归属**           | 类内部实现（`implements Comparable<T>`）      | 独立外部类或匿名类（`implements Comparator<T>`） |
| **核心方法**           | `int compareTo(T o)`                          | `int compare(T o1, T o2)`                     |
| **排序规则**           | 自然排序（仅一种默认规则）                    | 自定义排序（可定义多种规则）                  |
| **侵入性**             | 需要修改类源码                                | 不修改类源码                                  |
| **灵活性**             | 低（每个类仅一种排序方式）                    | 高（可针对同一类定义多个比较器）              |
| **使用场景**           | 类自身需要默认排序（如 `String`、`Integer`）   | 动态排序、第三方类扩展排序、多规则排序        |
| **调用方式**           | `Collections.sort(list)`                      | `Collections.sort(list, comparator)`          |
| **典型实现位置**       | 类内部                                        | 单独类、匿名类或 Lambda 表达式                |
| **排序控制权**         | 类自身控制                                    | 调用方控制                                    |
| **多规则支持**         | 不支持                                        | 支持（通过定义不同 `Comparator` 实现）         |


## 修饰符

| 修饰符 | 作用范围 | 使用场景 |
| -- | -- | -- |
| public | 所有包都可获取 | 常量、API、工具类、作为框架或库的入口 |
| protected | 同包及其不同包下的子类 | 父类中的模板方法、可扩展的钩子方法 |
| default | 同包 | 同一包内的类需要共享实现细节，但无需对外暴露，防止被外部包误用 |
| private | 同类 | 隐藏类的内部实现细节，如成员变量、辅助方法，强制通过公共方法访问数据（如通过Getter/Setter添加校验逻辑） |

始终牢记：包名的层级关系（如 pkg1 和 pkg1.sub）在 Java 中仅用于组织代码结构，**不影响访问修饰符的权限范围**。

> 关于接口中的访问修饰符
> 接口本身的定义简写了 abstract 关键字
> Java8之前
接口中的方法全部是抽象方法，默认public abstract 修饰，也只能是public abstract修饰，public abstract可以省略
>
> Java8及之后
> 接口中的方法有抽象方法（abstract），默认方法（default），静态方法（static）接口中所有方法的访问权限修饰符都是public，也只能是public，public 可以省略
